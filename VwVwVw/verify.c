//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2020 Retargetable Decompiler <info@retdec.com>
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int int128_t;
typedef int int256_t;

// ------------------- Function Prototypes --------------------

int entry_point(int a1, int a2, int a3, int a4);
int function_400478(void);
int32_t function_4004b0(char *s);
int32_t function_4004c0(char *format, ...);
int32_t function_4004d0(int main, int32_t argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)());
int32_t function_4004e0(int *s1, int *s2, int32_t n);
int *function_4004f0(int32_t size);
void function_400500(void);
int function_400540(void);
int function_400580(int *a1);
int function_4005c0(void);
int function_4005e0(void);
int function_400606(int a1);
int main(int a1, int binary, int a3);
int function_4023b0(int a1, int a2, int a3);
int function_402420(void);
int function_402424(void);

// --------------------- Global Variables ---------------------

char *g1 = "\x69\x7a\x12\x2d\x34\x02\x28\x1a\x6a\x6e\x0e\x01\x25\x13\x05\x31\x6b\x57\x19\x21\x26\x11\x16\x32\x69\x6e\x2c\x26\x36\x3f\x30\x20";
int g2 = 0x4005e0;
int g3 = 0x4005c0;
int g4 = 0;
int g5 = 0;
char g6 = 0;
int g7;      // 0x603057
int idx = 0; // rbx
int g9 = 0;  // rsi
int32_t g10;
int256_t g11_OR_result = 0; // ymm0
int256_t g12 = 0;           // ymm1

// ------------------------ Functions -------------------------

// Address range: 0x400478 - 0x400492
int function_400478(void)
{
    // 0x400478
    int result; // 0x400491
    if (g5 != 0)
    {
        // 0x400488
        __gmon_start__();
        result = &g10;
    }
    else
    {
        result = 0;
    }
    // 0x40048d
    return result;
}

// Address range: 0x4004b0 - 0x4004b6
int32_t function_4004b0(char *s)
{
    // 0x4004b0
    return strlen(s);
}

// Address range: 0x4004c0 - 0x4004c6
int32_t function_4004c0(char *format, ...)
{
    // 0x4004c0
    return printf(format);
}

// Address range: 0x4004d0 - 0x4004d6
int32_t function_4004d0(int main, int32_t argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)())
{
    // 0x4004d0
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x4004e0 - 0x4004e6
int32_t function_4004e0(int *s1, int *s2, int32_t n)
{
    // 0x4004e0
    return memcmp(s1, s2, n);
}

// Address range: 0x4004f0 - 0x4004f6
int *function_4004f0(int32_t size)
{
    // 0x4004f0
    return malloc(size);
}

// Address range: 0x400500 - 0x400506
void function_400500(void)
{
    // 0x400500
    __gmon_start__();
}

// Address range: 0x400510 - 0x40053a
int entry_point(int a1, int a2, int a3, int a4)
{
    // 0x400510
    int v1;
    __libc_start_main(0x401a4a, (int32_t)a4, (char **)&v1, (void (*)())0x4023b0, (void (*)())0x402420, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x400540 - 0x400572
int function_400540(void)
{
    int result; // 0x400571
    if ((uint)((int)&g7 - (int)&g6) >= 14 && (int)&g7 - (int)&g6 != 14)
    {
        result = 0;
    }
    else
    {
        result = (int)&g7 - (int)&g6;
    }
    // 0x400570
    return result;
}

// Address range: 0x400580 - 0x4005ba
int function_400580(int *a1)
{
    // 0x4005b8
    return 0;
}

// Address range: 0x4005c0 - 0x4005dc
int function_4005c0(void)
{
    // 0x4005c0
    int result; // 0x4005cd
    if (g6 != 0)
    {
        // branch -> 0x4005da
    }
    else
    {
        // 0x4005c9
        result = function_400540();
        g6 = 1;
    }
    // 0x4005da
    return result;
}

// Address range: 0x4005e0 - 0x400606
int function_4005e0(void)
{
    // 0x4005eb
    return function_400580(&g4);
}

// Address range: 0x400606 - 0x401a4a
int function_400606(int a1)
{
    // 0x400606
    int256_t v1;
    __asm_vmovdqa(v1, g11_OR_result);
    int128_t v2 = __asm_vmovd(0);                               // 0x4009dd
    int128_t v3 = __asm_vmovdqa_1(__asm_vpinsrb(v2, 0, 1));     // 0x4009f2
    int128_t v4 = __asm_vmovd(0);                               // 0x400a03
    int128_t v5 = __asm_vmovdqa_1(__asm_vpinsrb(v4, 0, 1));     // 0x400a18
    int128_t v6 = __asm_vmovd(0);                               // 0x400a29
    int128_t v7 = __asm_vmovdqa_1(__asm_vpinsrb(v6, 0, 1));     // 0x400a3e
    int128_t v8 = __asm_vmovd(0);                               // 0x400a4f
    int128_t v9 = __asm_vmovdqa_1(__asm_vpinsrb(v8, 0, 1));     // 0x400a64
    int128_t v10 = __asm_vmovd(0);                              // 0x400a75
    int128_t v11 = __asm_vmovdqa_1(__asm_vpinsrb(v10, 0, 1));   // 0x400a8a
    int128_t v12 = __asm_vmovd(4);                              // 0x400a9b
    int128_t v13 = __asm_vmovdqa_1(__asm_vpinsrb(v12, 4, 1));   // 0x400ab0
    int128_t v14 = __asm_vmovd(4);                              // 0x400ac1
    int128_t v15 = __asm_vmovdqa_1(__asm_vpinsrb(v14, 8, 1));   // 0x400ad6
    int128_t v16 = __asm_vmovd(8);                              // 0x400ae7
    int128_t v17 = __asm_vmovdqa_1(__asm_vpinsrb(v16, 12, 1));  // 0x400afc
    int128_t v18 = __asm_vmovdqa_1(__asm_vpunpcklwd(v3, v5));   // 0x400b05
    int128_t v19 = __asm_vmovdqa_1(__asm_vpunpcklwd(v7, v9));   // 0x400b0d
    int128_t v20 = __asm_vmovdqa_1(__asm_vpunpcklwd(v11, v13)); // 0x400b15
    int128_t v21 = __asm_vmovdqa_1(__asm_vpunpcklwd(v15, v17)); // 0x400b1d
    int128_t v22 = __asm_vmovdqa_1(__asm_vpunpckldq(v18, v19)); // 0x400b25
    int128_t v23 = __asm_vpunpckldq(v20, v21);                  // 0x400b29
    __asm_vmovdqa_1(__asm_vpunpcklqdq(v22, v23));
    // combine a preset sequence 0000000000000000 000004040408080c ==> xmm1

    int128_t v24 = __asm_vmovd(0);                                     // 0x400b42
    int128_t v25 = __asm_vmovdqa_1(__asm_vpinsrb(v24, 0, 1));          // 0x400b57
    int128_t v26 = __asm_vmovd(0);                                     // 0x400b68
    int128_t v27 = __asm_vmovdqa_1(__asm_vpinsrb(v26, 0, 1));          // 0x400b7d
    int128_t v28 = __asm_vmovd(0);                                     // 0x400b8e
    int128_t v29 = __asm_vmovdqa_1(__asm_vpinsrb(v28, 0, 1));          // 0x400ba3
    int128_t v30 = __asm_vmovd(0);                                     // 0x400bb4
    int128_t v31 = __asm_vmovdqa_1(__asm_vpinsrb(v30, 0, 1));          // 0x400bc9
    int128_t v32 = __asm_vmovd(0);                                     // 0x400bda
    int128_t v33 = __asm_vmovdqa_1(__asm_vpinsrb(v32, 0, 1));          // 0x400bef
    int128_t v34 = __asm_vmovd(4);                                     // 0x400c00
    int128_t v35 = __asm_vmovdqa_1(__asm_vpinsrb(v34, 4, 1));          // 0x400c15
    int128_t v36 = __asm_vmovd(4);                                     // 0x400c26
    int128_t v37 = __asm_vmovdqa_1(__asm_vpinsrb(v36, 8, 1));          // 0x400c3b
    int128_t v38 = __asm_vmovd(8);                                     // 0x400c4c
    int128_t v39 = __asm_vmovdqa_1(__asm_vpinsrb(v38, 12, 1));         // 0x400c61
    int128_t v40 = __asm_vmovdqa_1(__asm_vpunpcklwd(v25, v27));        // 0x400c6a
    int128_t v41 = __asm_vmovdqa_1(__asm_vpunpcklwd(v29, v31));        // 0x400c73
    int128_t v42 = __asm_vmovdqa_1(__asm_vpunpcklwd(v33, v35));        // 0x400c7b
    int128_t v43 = __asm_vmovdqa_1(__asm_vpunpcklwd(v37, v39));        // 0x400c83
    int128_t v44 = __asm_vmovdqa_1(__asm_vpunpckldq(v40, v41));        // 0x400c8b
    int128_t v45 = __asm_vpunpcklqdq(v44, __asm_vpunpckldq(v42, v43)); // 0x400c93
    // second set of preset sequence 0000000000000000 000004040408080c ==> xmm0

    int256_t v46;
    __asm_vmovdqa(v46, __asm_vinserti128(g12, v45, 1));
    int256_t v47;
    __asm_vmovdqa(v47, __asm_vmovdqa_2(v46));
    // combine 2 sets and save it in [rbp-0x2b0]

    int128_t v48 = __asm_vmovd(30);                             // 0x400f81
    int128_t v49 = __asm_vmovdqa_1(__asm_vpinsrb(v48, 30, 1));  // 0x400f96
    int128_t v50 = __asm_vmovd(30);                             // 0x400fa7
    int128_t v51 = __asm_vmovdqa_1(__asm_vpinsrb(v50, 30, 1));  // 0x400fbc
    int128_t v52 = __asm_vmovd(30);                             // 0x400fcd
    int128_t v53 = __asm_vmovdqa_1(__asm_vpinsrb(v52, 30, 1));  // 0x400fe2
    int128_t v54 = __asm_vmovd(30);                             // 0x400ff3
    int128_t v55 = __asm_vmovdqa_1(__asm_vpinsrb(v54, 30, 1));  // 0x401008
    int128_t v56 = __asm_vmovd(30);                             // 0x401019
    int128_t v57 = __asm_vmovdqa_1(__asm_vpinsrb(v56, 30, 1));  // 0x40102e
    int128_t v58 = __asm_vmovd(30);                             // 0x40103f
    int128_t v59 = __asm_vmovdqa_1(__asm_vpinsrb(v58, 30, 1));  // 0x401054
    int128_t v60 = __asm_vmovd(30);                             // 0x401065
    int128_t v61 = __asm_vmovdqa_1(__asm_vpinsrb(v60, 30, 1));  // 0x40107a
    int128_t v62 = __asm_vmovd(30);                             // 0x40108b
    int128_t v63 = __asm_vmovdqa_1(__asm_vpinsrb(v62, 30, 1));  // 0x4010a0
    int128_t v64 = __asm_vmovdqa_1(__asm_vpunpcklwd(v49, v51)); // 0x4010a9
    int128_t v65 = __asm_vmovdqa_1(__asm_vpunpcklwd(v53, v55)); // 0x4010b1
    int128_t v66 = __asm_vmovdqa_1(__asm_vpunpcklwd(v57, v59)); // 0x4010b9
    int128_t v67 = __asm_vmovdqa_1(__asm_vpunpcklwd(v61, v63)); // 0x4010c1
    int128_t v68 = __asm_vmovdqa_1(__asm_vpunpckldq(v64, v65)); // 0x4010c9
    int128_t v69 = __asm_vpunpckldq(v66, v67);                  // 0x4010cd
    __asm_vmovdqa_1(__asm_vpunpcklqdq(v68, v69));
    // xmm1 = 0x1e * 32

    int128_t v70 = __asm_vmovd(30);                                    // 0x4010e6
    int128_t v71 = __asm_vmovdqa_1(__asm_vpinsrb(v70, 30, 1));         // 0x4010fb
    int128_t v72 = __asm_vmovd(30);                                    // 0x40110c
    int128_t v73 = __asm_vmovdqa_1(__asm_vpinsrb(v72, 30, 1));         // 0x401121
    int128_t v74 = __asm_vmovd(30);                                    // 0x401132
    int128_t v75 = __asm_vmovdqa_1(__asm_vpinsrb(v74, 30, 1));         // 0x401147
    int128_t v76 = __asm_vmovd(30);                                    // 0x401158
    int128_t v77 = __asm_vmovdqa_1(__asm_vpinsrb(v76, 30, 1));         // 0x40116d
    int128_t v78 = __asm_vmovd(30);                                    // 0x40117e
    int128_t v79 = __asm_vmovdqa_1(__asm_vpinsrb(v78, 30, 1));         // 0x401193
    int128_t v80 = __asm_vmovd(30);                                    // 0x4011a4
    int128_t v81 = __asm_vmovdqa_1(__asm_vpinsrb(v80, 30, 1));         // 0x4011b9
    int128_t v82 = __asm_vmovd(30);                                    // 0x4011ca
    int128_t v83 = __asm_vmovdqa_1(__asm_vpinsrb(v82, 30, 1));         // 0x4011df
    int128_t v84 = __asm_vmovd(30);                                    // 0x4011f0
    int128_t v85 = __asm_vmovdqa_1(__asm_vpinsrb(v84, 30, 1));         // 0x401205
    int128_t v86 = __asm_vmovdqa_1(__asm_vpunpcklwd(v71, v73));        // 0x40120e
    int128_t v87 = __asm_vmovdqa_1(__asm_vpunpcklwd(v75, v77));        // 0x401217
    int128_t v88 = __asm_vmovdqa_1(__asm_vpunpcklwd(v79, v81));        // 0x40121f
    int128_t v89 = __asm_vmovdqa_1(__asm_vpunpcklwd(v83, v85));        // 0x401227
    int128_t v90 = __asm_vmovdqa_1(__asm_vpunpckldq(v86, v87));        // 0x40122f
    int128_t v91 = __asm_vpunpcklqdq(v90, __asm_vpunpckldq(v88, v89)); // 0x401237
    // [rbp-0x70] = 0x1e * 32 => mask

    int256_t v92;
    __asm_vmovdqa(v92, __asm_vinserti128(g12, v91, 1));
    int256_t v93 = __asm_vmovdqa_2(v92); // 0x401246
    int256_t v94;
    __asm_vmovdqa(v94, __asm_vpand(v93, v1));
    // AND or_result with mask
    int256_t v95 = __asm_vmovdqa_2(v1); // 0x40125b
    int256_t v96;
    __asm_vmovdqa(v96, __asm_vpxor(v95, v94));
    // XOR or_result with and_result

    int256_t v97;
    __asm_vmovdqa(v97, __asm_vmovdqa_2(v94));
    int256_t v98 = __asm_vmovdqa_2(v97); // 0x40128d
    int128_t v99 = __asm_vmovd(1);       // 0x401295
    int256_t v100;
    __asm_vmovdqa(v100, __asm_vpsrlw(v98, v99));
    // right shift and_result by 1

    int256_t v101;
    __asm_vmovdqa(v101, __asm_vmovdqa_2(v47));
    int256_t v102;
    __asm_vmovdqa(v102, __asm_vmovdqa_2(v100));
    int256_t v103 = __asm_vmovdqa_2(v102); // 0x4012c9
    int256_t v104 = __asm_vmovdqa_2(v101); // 0x4012d1
    int256_t v105;
    __asm_vmovdqa(v105, __asm_vpshufb(v104, v103));
    // shuffle mask with shift_result

    int256_t v106;
    __asm_vmovdqa(v106, __asm_vmovdqa_2(v96));
    int256_t v107 = __asm_vmovdqa_2(v106);              // 0x401300
    int256_t v108 = __asm_vpsrlw(v107, __asm_vmovd(4)); // 0x401310
    int256_t v109;
    __asm_vmovdqa(v109, __asm_vpor(v108, v96));
    int256_t v110 = __asm_vmovdqa_2(v105); // 0x401324
    int256_t v111;
    __asm_vmovdqa(v111, __asm_vpor(v110, v109));
    // shift xor_result to the right by 4, OR with xor_result
    // then OR with shuffle result

    g9 = 65;
    int128_t v112 = __asm_vmovd(65);                               // 0x4016e8
    int128_t v113 = __asm_vmovdqa_1(__asm_vpinsrb(v112, 65, 1));   // 0x4016fd
    int128_t v114 = __asm_vmovd(71);                               // 0x40170e
    int128_t v115 = __asm_vmovdqa_1(__asm_vpinsrb(v114, 71, 1));   // 0x401723
    int128_t v116 = __asm_vmovd(65);                               // 0x401734
    int128_t v117 = __asm_vmovdqa_1(__asm_vpinsrb(v116, 65, 1));   // 0x401749
    int128_t v118 = __asm_vmovd(-4);                               // 0x40175a
    int128_t v119 = __asm_vmovdqa_1(__asm_vpinsrb(v118, 252, 1));  // 0x40176f
    int128_t v120 = __asm_vmovd(71);                               // 0x401780
    int128_t v121 = __asm_vmovdqa_1(__asm_vpinsrb(v120, 71, 1));   // 0x401795
    int128_t v122 = __asm_vmovd(-4);                               // 0x4017a6
    int128_t v123 = __asm_vmovdqa_1(__asm_vpinsrb(v122, 252, 1));  // 0x4017bb
    int128_t v124 = __asm_vmovd(71);                               // 0x4017cc
    int128_t v125 = __asm_vmovdqa_1(__asm_vpinsrb(v124, 71, 1));   // 0x4017e1
    int128_t v126 = __asm_vmovd(-19);                              // 0x4017f2
    int128_t v127 = __asm_vmovdqa_1(__asm_vpinsrb(v126, 240, 1));  // 0x401807
    int128_t v128 = __asm_vmovdqa_1(__asm_vpunpcklwd(v113, v115)); // 0x401810
    int128_t v129 = __asm_vmovdqa_1(__asm_vpunpcklwd(v117, v119)); // 0x401818
    int128_t v130 = __asm_vmovdqa_1(__asm_vpunpcklwd(v121, v123)); // 0x401820
    int128_t v131 = __asm_vmovdqa_1(__asm_vpunpcklwd(v125, v127)); // 0x401828
    int128_t v132 = __asm_vmovdqa_1(__asm_vpunpckldq(v128, v129)); // 0x401830
    int128_t v133 = __asm_vpunpckldq(v130, v131);                  // 0x401834
    __asm_vmovdqa_1(__asm_vpunpcklqdq(v132, v133));
    int128_t v134 = __asm_vmovd(65);                                       // 0x40184d
    int128_t v135 = __asm_vmovdqa_1(__asm_vpinsrb(v134, 65, 1));           // 0x401862
    int128_t v136 = __asm_vmovd(71);                                       // 0x401873
    int128_t v137 = __asm_vmovdqa_1(__asm_vpinsrb(v136, 71, 1));           // 0x401888
    int128_t v138 = __asm_vmovd(65);                                       // 0x401899
    int128_t v139 = __asm_vmovdqa_1(__asm_vpinsrb(v138, 65, 1));           // 0x4018ae
    int128_t v140 = __asm_vmovd(-4);                                       // 0x4018bf
    int128_t v141 = __asm_vmovdqa_1(__asm_vpinsrb(v140, 252, 1));          // 0x4018d4
    int128_t v142 = __asm_vmovd(71);                                       // 0x4018e5
    int128_t v143 = __asm_vmovdqa_1(__asm_vpinsrb(v142, 71, 1));           // 0x4018fa
    int128_t v144 = __asm_vmovd(-4);                                       // 0x40190b
    int128_t v145 = __asm_vmovdqa_1(__asm_vpinsrb(v144, 252, 1));          // 0x401920
    int128_t v146 = __asm_vmovd(71);                                       // 0x401931
    int128_t v147 = __asm_vmovdqa_1(__asm_vpinsrb(v146, 71, 1));           // 0x401946
    int128_t v148 = __asm_vmovd(-19);                                      // 0x401957
    int128_t v149 = __asm_vmovdqa_1(__asm_vpinsrb(v148, 240, 1));          // 0x40196c
    int128_t v150 = __asm_vmovdqa_1(__asm_vpunpcklwd(v135, v137));         // 0x401975
    int128_t v151 = __asm_vmovdqa_1(__asm_vpunpcklwd(v139, v141));         // 0x40197e
    int128_t v152 = __asm_vmovdqa_1(__asm_vpunpcklwd(v143, v145));         // 0x401986
    int128_t v153 = __asm_vmovdqa_1(__asm_vpunpcklwd(v147, v149));         // 0x40198e
    int128_t v154 = __asm_vmovdqa_1(__asm_vpunpckldq(v150, v151));         // 0x401996
    int128_t v155 = __asm_vpunpcklqdq(v154, __asm_vpunpckldq(v152, v153)); // 0x40199e
    int256_t v156;
    __asm_vmovdqa(v156, __asm_vinserti128(v103, v155, 1));
    // another reset sequence mask * 2

    int256_t v157;
    __asm_vmovdqa(v157, __asm_vmovdqa_2(v156));
    int256_t v158;
    __asm_vmovdqa(v158, __asm_vmovdqa_2(v157));
    int256_t v159;
    __asm_vmovdqa(v159, __asm_vmovdqa_2(v111));
    int256_t v160 = __asm_vmovdqa_2(v159); // 0x4019e0
    int256_t v161 = __asm_vmovdqa_2(v158); // 0x4019e8
    int256_t v162;
    __asm_vmovdqa(v162, __asm_vpshufb(v161, v160));
    // shuffle mask with or_result

    int256_t v163;
    __asm_vmovdqa(v163, __asm_vmovdqa_2(v1));
    int256_t v164;
    __asm_vmovdqa(v164, __asm_vmovdqa_2(v162));
    int256_t v165 = __asm_vmovdqa_2(v163); // 0x401a1d
    __asm_vpaddb(v165, __asm_vmovdqa_2(v164));
    // add shuffle result with the input or_result
    return 240;
}

// Address range: 0x401a4a - 0x4023a3
int main(int argc, int binary, int flag)
{
    if ((int32_t)argc <= 1)
    {
        // 0x401a81
        printf("usage: ./verify binary");
        // 0x40238d
        return 0;
    }
    int flag = (int)(binary + 8); // 0x401aa1
    char *str = (char *)flag;     // 0x401ab3
    if (strlen(str) != 24)
    {
        // 0x401ac1
        printf("wrong!");
        // 0x40238d
        return 0;
    }
    // 0x401b5d
    idx = 0;
    if (idx < 24)
    {
        int cnt = 0;                                                          // 0x401b5d591
        int v3 = flag;                                                        // 0x401af6
        char path_char = *(char *)(binary + 0 % (int)strlen((char *)binary)); // 0x401b4c
        int flag_char = (int)*(char *)v3;                                     // 0x401b4f
        *(char *)v3 = (char)flag_char ^ path_char;
        int v6 = cnt + 1;
        idx = v6;
        while (idx < 24)
        {
            // 0x401ae6
            cnt = v6;
            v3 = cnt + flag;
            path_char = *(char *)(binary + cnt % (int)strlen((char *)binary));
            // path_char is a char each iteration
            // first 24 chars of the binary's path
            flag_char = (int)*(char *)v3;
            *(char *)v3 = (char)flag_char ^ path_char;
            v6 = cnt + 1;
            idx = v6;
        }
    }
    // XOR first 24 chars of binary path with flag

    int *mem = malloc(32); // 0x401b83
    int128_t XOR_1_16;
    __asm_vmovaps(XOR_1_16, __asm_vmovdqu(*(int128_t *)flag));
    // first 16 bytes of the xor-ed flag
    int128_t XOR_13_24;
    __asm_vmovaps(XOR_13_24, __asm_vmovdqu(*(int128_t *)(flag + 12)));
    // xor-flag[13:24]
    int128_t v9 = __asm_vmovd(1);                              // 0x401cf1
    int128_t v10 = __asm_vmovdqa_1(__asm_vpinsrb(v9, 0, 1));   // 0x401d06
    int128_t v11 = __asm_vmovd(2);                             // 0x401d17
    int128_t v12 = __asm_vmovdqa_1(__asm_vpinsrb(v11, 1, 1));  // 0x401d2c
    int128_t v13 = __asm_vmovd(4);                             // 0x401d3d
    int128_t v14 = __asm_vmovdqa_1(__asm_vpinsrb(v13, 3, 1));  // 0x401d52
    int128_t v15 = __asm_vmovd(5);                             // 0x401d63
    int128_t v16 = __asm_vmovdqa_1(__asm_vpinsrb(v15, 4, 1));  // 0x401d78
    int128_t v17 = __asm_vmovd(7);                             // 0x401d89
    int128_t v18 = __asm_vmovdqa_1(__asm_vpinsrb(v17, 6, 1));  // 0x401d9e
    int128_t v19 = __asm_vmovd(8);                             // 0x401daf
    int128_t v20 = __asm_vmovdqa_1(__asm_vpinsrb(v19, 7, 1));  // 0x401dc4
    int128_t v21 = __asm_vmovd(10);                            // 0x401dd5
    int128_t v22 = __asm_vmovdqa_1(__asm_vpinsrb(v21, 9, 1));  // 0x401dea
    int128_t v23 = __asm_vmovd(11);                            // 0x401dfb
    int128_t v24 = __asm_vmovdqa_1(__asm_vpinsrb(v23, 10, 1)); // 0x401e10
    // xmm1-8 filled

    int128_t v25 = __asm_vmovdqa_1(__asm_vpunpcklwd(v10, v12)); // 0x401e19
    int128_t v26 = __asm_vmovdqa_1(__asm_vpunpcklwd(v14, v16)); // 0x401e21
    int128_t v27 = __asm_vmovdqa_1(__asm_vpunpcklwd(v18, v20)); // 0x401e29
    int128_t v28 = __asm_vmovdqa_1(__asm_vpunpcklwd(v22, v24)); // 0x401e31
    // appended together: xmm1-4 filled

    int128_t v29 = __asm_vmovdqa_1(__asm_vpunpckldq(v25, v26)); // 0x401e39
    int128_t v30 = __asm_vpunpckldq(v27, v28);                  // 0x401e3d
    __asm_vmovdqa_1(__asm_vpunpcklqdq(v29, v30));
    // appended all to xmm1

    int128_t v31 = __asm_vmovd(1);                                     // 0x401e56
    int128_t v32 = __asm_vmovdqa_1(__asm_vpinsrb(v31, 0, 1));          // 0x401e6b
    int128_t v33 = __asm_vmovd(2);                                     // 0x401e7c
    int128_t v34 = __asm_vmovdqa_1(__asm_vpinsrb(v33, 1, 1));          // 0x401e91
    int128_t v35 = __asm_vmovd(4);                                     // 0x401ea2
    int128_t v36 = __asm_vmovdqa_1(__asm_vpinsrb(v35, 3, 1));          // 0x401eb7
    int128_t v37 = __asm_vmovd(5);                                     // 0x401ec8
    int128_t v38 = __asm_vmovdqa_1(__asm_vpinsrb(v37, 4, 1));          // 0x401edd
    int128_t v39 = __asm_vmovd(7);                                     // 0x401eee
    int128_t v40 = __asm_vmovdqa_1(__asm_vpinsrb(v39, 6, 1));          // 0x401f03
    int128_t v41 = __asm_vmovd(8);                                     // 0x401f14
    int128_t v42 = __asm_vmovdqa_1(__asm_vpinsrb(v41, 7, 1));          // 0x401f29
    int128_t v43 = __asm_vmovd(10);                                    // 0x401f3a
    int128_t v44 = __asm_vmovdqa_1(__asm_vpinsrb(v43, 9, 1));          // 0x401f4f
    int128_t v45 = __asm_vmovd(11);                                    // 0x401f60
    int128_t v46 = __asm_vmovdqa_1(__asm_vpinsrb(v45, 10, 1));         // 0x401f75
    int128_t v47 = __asm_vmovdqa_1(__asm_vpunpcklwd(v32, v34));        // 0x401f7e
    int128_t v48 = __asm_vmovdqa_1(__asm_vpunpcklwd(v36, v38));        // 0x401f87
    int128_t v49 = __asm_vmovdqa_1(__asm_vpunpcklwd(v40, v42));        // 0x401f8f
    int128_t v50 = __asm_vmovdqa_1(__asm_vpunpcklwd(v44, v46));        // 0x401f97
    int128_t v51 = __asm_vmovdqa_1(__asm_vpunpckldq(v47, v48));        // 0x401f9f
    int128_t v52 = __asm_vpunpcklqdq(v51, __asm_vpunpckldq(v49, v50)); // 0x401fa7
    // xmm0 stores the same thing as xmm1

    int256_t v53;
    int256_t v54; // ymm1
    __asm_vmovdqa(v53, __asm_vinserti128(v54, v52, 1));
    int256_t v55 = __asm_vmovdqa_2(v53); // 0x401fb6
    int256_t v56;
    __asm_vmovdqa(v56, v55);
    // 2 copies of the 256bit sequence

    int128_t v57 = __asm_vmovdqa_1(XOR_13_24); // 0x401fc3
    int128_t v58;
    __asm_vmovaps(v58, __asm_vmovdqa_1(XOR_1_16));
    __asm_vmovdqa_1(__asm_vmovdqa_1(v58));
    // load the modified flag parts into xmm0 and xmm1

    int256_t v59;
    __asm_vmovdqa(v59, __asm_vinserti128(v55, v57, 1));
    // concat xmm0 & xmm1

    int256_t v60;
    __asm_vmovdqa(v60, __asm_vmovdqa_2(v56));
    int256_t v61 = __asm_vmovdqa_2(v60); // 0x402002
    // load byte sequence into ymm1
    int256_t v62 = __asm_vmovdqa_2(v59); // 0x402007
    // load modified and concat-ed flag into ymm0

    // shuffle according to mask
    int256_t v63;
    __asm_vmovdqa(v63, __asm_vpshufb(v62, v61));
    int256_t v64;
    // broadcast 0xfc0fc00 to 32 bytes (repetition) as mask1
    __asm_vmovdqa(v64, __asm_vpbroadcastd(0xfc0fc00));
    int256_t v65 = __asm_vmovdqa_2(v64); // 0x402037
    int256_t v66;
    __asm_vmovdqa(v66, __asm_vmovdqa_2(v63));
    int256_t v67;
    __asm_vmovdqa(v67, v65);
    int256_t v68 = __asm_vmovdqa_2(v66); // 0x402057
    int256_t v69 = __asm_vmovdqa_2(v67); // 0x40205f
    int256_t v70;
    __asm_vmovdqa(v70, __asm_vpand(v68, v69));
    // move the same stuff around and AND the two

    int256_t v71;
    // broadcast 0x4000040 to 32 bytes (repetition) as mask2
    __asm_vmovdqa(v71, __asm_vpbroadcastd(0x4000040));
    int256_t v72 = __asm_vmovdqa_2(v71); // 0x40208e
    int256_t v73;
    __asm_vmovdqa(v73, __asm_vmovdqa_2(v70));
    int256_t v74;
    __asm_vmovdqa(v74, v72);
    int256_t v75 = __asm_vmovdqa_2(v74); // 0x4020ae
    int256_t v76 = __asm_vmovdqa_2(v73); // 0x4020b6
    int256_t v77;
    __asm_vmovdqa(v77, __asm_vpmulhuw(v76, v75));
    // multiply each 2-bytes with mask2 then save the high 16 bits of the result

    int256_t v78;
    // broadcast 0x3f03f0 to 32 bytes (repetition) as mask3
    __asm_vmovdqa(v78, __asm_vpbroadcastd(0x3f03f0));
    int256_t v79 = __asm_vmovdqa_2(v78); // 0x4020e5
    int256_t v80;
    __asm_vmovdqa(v80, __asm_vmovdqa_2(v63));
    int256_t v81;
    __asm_vmovdqa(v81, v79);
    int256_t v82 = __asm_vmovdqa_2(v80); // 0x402105
    int256_t v83 = __asm_vmovdqa_2(v81); // 0x40210d
    int256_t v84;
    __asm_vmovdqa(v84, __asm_vpand(v82, v83));
    // AND shuffle result and mask3

    int256_t v85;
    // broadcast 0x1000010 to 32 bytes (repetition) as mask4
    __asm_vmovdqa(v85, __asm_vpbroadcastd(0x1000010));
    int256_t v86 = __asm_vmovdqa_2(v85); // 0x40213c
    int256_t v87;
    __asm_vmovdqa(v87, __asm_vmovdqa_2(v84));
    int256_t v88;
    __asm_vmovdqa(v88, v86);
    int256_t v89 = __asm_vmovdqa_2(v87); // 0x40215c
    int256_t v90 = __asm_vmovdqa_2(v88); // 0x402164
    int256_t v91;
    __asm_vmovdqa(v91, __asm_vpmullw(v89, v90));
    // multiply each 2-bytes with mask4 then save the low 16 bits of the result

    int256_t v92;
    __asm_vmovdqa(v92, __asm_vmovdqa_2(v77));
    int256_t v93;
    __asm_vmovdqa(v93, __asm_vmovdqa_2(v91));
    int256_t v94 = __asm_vmovdqa_2(v92); // 0x402198
    g12 = v94;
    int256_t v95 = __asm_vmovdqa_2(v93); // 0x4021a0
    int256_t v96;
    __asm_vmovdqa(v96, __asm_vpor(v94, v95));
    // OR mulhuw result and mullw result

    int256_t v97 = __asm_vmovdqa_2(v96); // 0x4021b4
    g11_OR_result = v97;
    function_400606((int)&g10);

    int256_t v98;
    __asm_vmovdqa(v98, v97);
    int256_t v99;
    __asm_vmovdqa(v99, __asm_vmovdqa_2(v98));
    int256_t v100 = __asm_vmovdqa_2(v99); // 0x4021e7
    __asm_vmovdqu_3(*(int256_t *)mem, v100);
    // save final result to mem location

    int32_t len = strlen((char *)mem); // 0x40220c
    if (len > 0)
    {
        // xor each char in the malloc memory with the path
        int idx = 0;
        int v102 = idx + (int)mem;                                      // 0x402233
        char path_char = *(char *)(g9 + idx % (int)strlen((char *)g9)); // 0x402287
        int mem_char = (int)*(char *)v102;                              // 0x40228a
        *(char *)v102 = (char)mem_char ^ path_char;
        while ((int32_t)(idx + 1) != len)
        {
            // 0x402223
            idx++;
            v102 = idx + (int)mem;
            path_char = *(char *)(g9 + idx % (int)strlen((char *)g9));
            mem_char = (int)*(char *)v102;
            *(char *)v102 = (char)mem_char ^ path_char;
        }
    }
    // 0x4022aa
    // compare first 32 bytes, if same return 0
    if (memcmp(mem, (int *)&g1, 32) == 0)
    {
        // 0x40234e
        // xor each char of the modified flag with the path again
        // to get back the original input flag
        if (strlen(str) != 0)
        {
            int idx = 0; // 0x40234e585
            // modified flag in address
            int v106 = idx + flag_addr;                             // 0x4022e7
            int new_flag_char = (int)*(char *)v106;                 // r14
            int32_t len2 = strlen((char *)&g1);                     // 0x402324
            char path_char = *(char *)(idx % (int)len2 + (int)&g1); // 0x40233d
            *(char *)v106 = (char)new_flag_char ^ path_char;
            while ((idx + 1) < 24)
            {
                // 0x4022d7
                idx = idx + 1;
                v106 = idx + flag_addr;
                new_flag_char = (int)*(char *)v106;
                len2 = strlen((char *)&g1);
                path_char = *(char *)(idx % (int)len2 + (int)&g1);
                *(char *)v106 = (char)new_flag_char ^ path_char;
            }
        }
        // 0x40236f
        printf("You got it FLAG{%s}\n", str);
    }
    // 0x40238d
    return 0;
}

// Address range: 0x4023b0 - 0x402415
int function_4023b0(int a1, int a2, int a3)
{
    int result = function_400478(); // 0x4023dc
    if ((int)&g3 - (int)&g2 >> 3 != 0)
    {
        int v1 = 0; // 0x4023fd2
        while (v1 + 1 != (int)&g3 - (int)&g2 >> 3)
        {
            // 0x4023f0
            v1++;
        }
    }
    // 0x402406
    return result;
}

// Address range: 0x402420 - 0x402422
int function_402420(void)
{
    // 0x402420
    int result; // rax
    return result;
}

// Address range: 0x402424 - 0x40242d
int function_402424(void)
{
    // 0x402424
    int result; // rax
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// void __gmon_start__(void);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// void * malloc(size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// int printf(const char * restrict format, ...);
// size_t strlen(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (5.4.0)
// Detected functions: 17
// Decompilation date: 2020-01-13 12:30:40
